# Copyright cocotb contributors
# Licensed under the Revised BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-3-Clause

# generated with mypy's stubgen script

from logging import Logger
from typing import Any, Callable

from cocotb.handle import GPIDiscovery

DRIVERS: int
ENUM: int
GENARRAY: int
INTEGER: int
LOADS: int
LOGIC: int
LOGIC_ARRAY: int
MEMORY: int
MODULE: int
NETARRAY: int
OBJECTS: int
PACKAGE: int
REAL: int
STRING: int
STRUCTURE: int
PACKED_STRUCTURE: int
UNKNOWN: int
RISING: int
FALLING: int
VALUE_CHANGE: int
RANGE_UP: int
RANGE_DOWN: int
RANGE_NO_DIR: int

class gpi_cb_hdl:
    def deregister(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class gpi_iterator_hdl:
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> gpi_iterator_hdl: ...
    def __next__(self) -> gpi_sim_hdl: ...

class gpi_sim_hdl:
    def get_const(self) -> bool: ...
    def get_definition_file(self) -> str: ...
    def get_definition_name(self) -> str: ...
    def get_handle_by_index(self, index: int) -> gpi_sim_hdl | None: ...
    def get_handle_by_name(
        self, name: str, discovery_method: GPIDiscovery | None = GPIDiscovery.AUTO
    ) -> gpi_sim_hdl | None: ...
    def get_indexable(self) -> bool: ...
    def get_name_string(self) -> str: ...
    def get_num_elems(self) -> int: ...
    def get_range(self) -> tuple[int, int, int]: ...
    def get_signal_val_binstr(self) -> str: ...
    def get_signal_val_long(self) -> int: ...
    def get_signal_val_real(self) -> float: ...
    def get_signal_val_str(self) -> bytes: ...
    def get_type(self) -> int: ...
    def get_type_string(self) -> str: ...
    def iterate(self, mode: int) -> gpi_iterator_hdl: ...
    def set_signal_val_binstr(self, action: int, value: str) -> None: ...
    def set_signal_val_int(self, action: int, value: int) -> None: ...
    def set_signal_val_real(self, action: int, value: float) -> None: ...
    def set_signal_val_str(self, action: int, value: bytes) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

def get_precision() -> int: ...
def get_root_handle(name: str | None) -> gpi_sim_hdl | None: ...
def get_sim_time() -> tuple[int, int]: ...
def get_simulator_product() -> str: ...
def get_simulator_version() -> str: ...
def is_running() -> bool: ...
def set_gpi_log_level(level: int) -> None: ...
def package_iterate() -> gpi_iterator_hdl: ...
def register_nextstep_callback(func: Callable[..., Any], *args: Any) -> gpi_cb_hdl: ...
def register_readonly_callback(func: Callable[..., Any], *args: Any) -> gpi_cb_hdl: ...
def register_rwsynch_callback(func: Callable[..., Any], *args: Any) -> gpi_cb_hdl: ...
def register_timed_callback(
    time: int, func: Callable[..., Any], *args: Any
) -> gpi_cb_hdl: ...
def register_value_change_callback(
    signal: gpi_sim_hdl, func: Callable[..., Any], edge: int, *args: Any
) -> gpi_cb_hdl: ...
def stop_simulator() -> None: ...

class cpp_clock:
    def __init__(self, signal: gpi_sim_hdl) -> None: ...
    def start(
        self, period_steps: int, high_steps: int, start_high: bool, set_action: int
    ) -> None: ...
    def stop(self) -> None: ...

def clock_create(hdl: gpi_sim_hdl) -> cpp_clock: ...
def initialize_logger(
    log_func: Callable[[Logger, int, str, int, str, str], None],
    get_logger: Callable[[str], Logger],
) -> None: ...
def set_sim_event_callback(sim_event_callback: Callable[[str], None]) -> None: ...
