# Copyright cocotb contributors
# Licensed under the Revised BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-3-Clause

ifneq ($(VHDL_SOURCES),)

results.xml:
	@echo "Skipping simulation as VHDL is not supported on simulator=$(SIM)"
debug: results.xml
clean::

else

CMD := verilator

ifeq ($(shell which $(CMD) 2>/dev/null),)
# Verilator is not in PATH, lets start searching for it
$(error Cannot find verilator.)
endif

# Do not directly append to COMPILE_ARGS, SIM_ARGS, EXTRA_ARGS etc.,
# because if a user sets these variables on the make command line,
# only the user's variable values will be seen.
# Instead, append to local variables.
_COMPILE_ARGS += $(COMPILE_ARGS)
_SIM_ARGS     += $(SIM_ARGS)
_EXTRA_ARGS   += $(EXTRA_ARGS)
_PLUSARGS     += $(PLUSARGS)

ifeq ($(VERILATOR_SIM_DEBUG), 1)
  _COMPILE_ARGS += --debug
  _PLUSARGS += +verilator+debug
  SIM_BUILD_FLAGS += -DVL_DEBUG
endif

ifeq ($(VERILATOR_TRACE),1)
  _EXTRA_ARGS += --trace --trace-structs
endif

ifdef COCOTB_HDL_TIMEPRECISION
  SIM_BUILD_FLAGS += -DVL_TIME_PRECISION_STR=$(COCOTB_HDL_TIMEPRECISION)
endif

SIM_BUILD_FLAGS += -std=c++11

_COMPILE_ARGS += --vpi --public-flat-rw --prefix Vtop -o $(TOPLEVEL) -LDFLAGS "-L$(LIB_DIR) -lcocotbvpi -lgpi -lcocotb -lgpilog -lcocotbutils"

$(SIM_BUILD)/Vtop.mk: $(VERILOG_SOURCES) $(CUSTOM_COMPILE_DEPS) $(COCOTB_SHARE_DIR)/lib/verilator/verilator.cpp
	$(CMD) -cc --exe -Mdir $(SIM_BUILD) -DCOCOTB_SIM=1 --top-module $(TOPLEVEL) $(_COMPILE_ARGS) $(_EXTRA_ARGS) $(VERILOG_SOURCES) $(COCOTB_SHARE_DIR)/lib/verilator/verilator.cpp

# Compilation phase
$(SIM_BUILD)/$(TOPLEVEL): $(SIM_BUILD)/Vtop.mk $(COCOTB_LIBS) $(COCOTB_VPI_LIB)
	CPPFLAGS="$(SIM_BUILD_FLAGS)" make -C $(SIM_BUILD) -f Vtop.mk

ifeq ($(OS),Msys)

OLD_PATH := $(shell echo "$(PATH)" | sed 's/(/\\(/g' | sed 's/)/\\)/g' | sed 's/ /\\ /g')
LIB_LOAD = PATH=$(OLD_PATH):$(LIB_DIR)
NEW_PYTHONPATH:=$(shell python -c "import sys, os; print(':'.join(['/'+dir.replace(os.sep,'/').replace(':','') for dir in sys.path]))")

else
LIB_LOAD := LD_LIBRARY_PATH=$(LIB_DIR):$(LD_LIBRARY_PATH)
NEW_PYTHONPATH := $(PYTHONPATH)
endif

$(COCOTB_RESULTS_FILE): $(SIM_BUILD)/$(TOPLEVEL) $(CUSTOM_SIM_DEPS) $(COCOTB_LIBS) $(COCOTB_VPI_LIB)
	-@rm -f $(COCOTB_RESULTS_FILE)

	PYTHONPATH=$(LIB_DIR):$(PWD):$(NEW_PYTHONPATH) LD_LIBRARY_PATH=$(LIB_DIR) $(LIB_LOAD) MODULE=$(MODULE) \
        TESTCASE=$(TESTCASE) TOPLEVEL=$(TOPLEVEL) TOPLEVEL_LANG=$(TOPLEVEL_LANG) COCOTB_SIM=1 \
        $< $(_PLUSARGS) $(_SIM_ARGS)

	# check that the file was actually created, since we can't set an exit code from cocotb
	test -f $(COCOTB_RESULTS_FILE)

debug: $(SIM_BUILD)/$(TOPLEVEL) $(CUSTOM_SIM_DEPS) $(COCOTB_LIBS) $(COCOTB_VPI_LIB)
	-@rm -f $(COCOTB_RESULTS_FILE)

	PYTHONPATH=$(LIB_DIR):$(PWD):$(NEW_PYTHONPATH) LD_LIBRARY_PATH=$(LIB_DIR) $(LIB_LOAD) MODULE=$(MODULE) \
        TESTCASE=$(TESTCASE) TOPLEVEL=$(TOPLEVEL) TOPLEVEL_LANG=$(TOPLEVEL_LANG) COCOTB_SIM=1 \
        gdb --args $< $(_PLUSARGS) $(_SIM_ARGS)

	# check that the file was actually created, since we can't set an exit code from cocotb
	test -f $(COCOTB_RESULTS_FILE)

clean::
	@rm -rf $(SIM_BUILD)
	@rm -f dump.vcd

endif
